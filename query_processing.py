# -*- coding: utf-8 -*-
"""Copy of end-to-end.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1anNT8YAifriFQ2LKvsns3zde47yaFRcJ
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd "/content/drive/MyDrive/tap bonds"
import scipy.optimize
from pyxirr import xirr
import pandas as pd
import os

from langchain.agents.agent_types import AgentType
from langchain_experimental.agents.agent_toolkits import create_csv_agent
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_experimental.agents.agent_toolkits import create_pandas_dataframe_agent
from langchain.docstore.document import Document
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain.prompts import PromptTemplate

from langchain.document_loaders import TextLoader
from langchain.text_splitter import CharacterTextSplitter
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain.vectorstores import FAISS
from langchain.chains import RetrievalQA
from langchain.tools import Tool
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_core.messages import SystemMessage, HumanMessage
from langchain.agents import AgentExecutor, create_openai_tools_agent
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.prompts import MessagesPlaceholder

if "GOOGLE_API_KEY" not in os.environ:
    os.environ["GOOGLE_API_KEY"] = "AIzaSyAIoIHHTm0-HJ_NaOksfxQ11BKXAovHp-A"

LANGSMITH_TRACING=True
LANGSMITH_ENDPOINT="https://api.smith.langchain.com"
LANGSMITH_API_KEY="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"
LANGSMITH_PROJECT="tap_bonds"

llm = ChatGoogleGenerativeAI(
    model="gemini-2.0-flash",
    temperature=0,
    max_tokens=None,
    timeout=None,
    max_retries=2,
)


embeddings = GoogleGenerativeAIEmbeddings(model="models/text-embedding-004")
llm = ChatGoogleGenerativeAI(
  model="gemini-2.0-flash",
  temperature=0,
  max_tokens=None,
  timeout=None,
  max_retries=2,)

df_bonds_directoy = pd.read_csv("data_dump/bonds_details_202503011115.csv")
df4 = pd.read_csv("data_dump/output_bonds2.csv")
df_cash_flows = pd.read_csv("data_dump/cashflows_202503011113.csv")
df_filtering = pd.read_csv("data_dump/output_bonds2.csv")
df_company_directoy = pd.read_csv("data_dump/merged_company_details2.csv")
df = pd.read_csv("data_dump/cashflows_202503011113.csv")


def Bonds_Directory_Agent(user_query):

    print("User Query : " , user_query)


    global df_bonds_directoy
    global embeddings
    global llm
    # Step 1: Extract the ISIN from the user query.
    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the ISIN mentioned.
        Query: {query}
        Only output the ISIN as a string.
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_ISIN = result.content.strip()

    # Filter the dataframe for the matching ISIN.
    df_isin = df_bonds_directoy[df_bonds_directoy["isin"] == possible_ISIN]
    df_isin.reset_index(drop=True, inplace=True)

    if df_isin.empty:
        return {"result": "No matching ISIN found."}



    # Step 3: Modify the query using the LLM to focus on the bond details.
    modification_prompt_template = PromptTemplate(
        template="""
    You are a financial analyst specializing in bond documentation.

    TASK: Rewrite the query below without writing the ISIN code or the company name only the information needed to be extrated .

    AVAILABLE DATA COLUMNS and their description
    - id : id
    - created_at : created_at
    - updated_at : updated_at
    - isin : isin
    - company_name : field provides the registered name of the entity issuing the bond or debenture
    - issue_size : the total value of the bond issuance in crores, indicating capital raised.
    - allotment_date : allotment_date
    - maturity_date : maturity_date
    - issuer_details : The issuer_details field contains a JSON object with issuer information including Corporate Identification Number (CIN), Legal Entity Identifier (LEI), and industry classifications
    - instrument_details : field contains specifications about the bond including security status, face value, issue price, tenure, and technical parameters defining its characteristics
    - coupon_details : field contains interest structure information including rate, type (simple/compound), calculation basis, and payment frequency.
    - redemption_details : JSON object provides information about bond redemption including put/call options and early redemption provisions.
    - credit_rating_details :  field contains current and historical credit ratings from various agencies.
    - listing_details : JSON object has information about where the bond trades, including exchange listings and related documentation
    - key_contacts_details : field contains contact information for parties involved with the bond including registrar, debt trustee, and lead managers.
    - key_documents_details : JSON object provides links to important documents such as prospectus, rating rationales, and regulatory filings.

    Original query: {query}

    Your rewritten query should focus on what information the user is asking and reference only one of the appropriate columns from the list above.

    Modified query:
    """,
        input_variables=["query"]
    )

    modification_prompt = modification_prompt_template.format(query=user_query)
    modification_result = llm.invoke(modification_prompt)
    modified_query = modification_result.content.strip()

    # Build the document from the filtered bond details.
    doc_content = "\n".join([f"{col}: {df_isin.at[0, col]}" for col in df_isin.columns])
    document = Document(page_content=doc_content)
    documents = [document]

    # Step 2: Split the text into smaller chunks for better retrieval.
    text_splitter = CharacterTextSplitter(separator="\n", chunk_size=500, chunk_overlap=50)
    docs = text_splitter.split_documents(documents)

    vectorstore = FAISS.from_documents(docs, embeddings)

    # Step 3: Create a custom prompt that focuses on bond details.
    custom_prompt = PromptTemplate(
        input_variables=["context", "question"],
        template="""You are a knowledgeable financial analyst specialized in bond details.
        Utilize the provided bond details to answer the following question. Output the answer nicely
        If the details are insufficient to answer the question, please indicate that explicitly.
        concentrate more on the "Original query" than the "Modified query"
        Bond Details:
        {context}

        Question:
        {question}

        Answer:"""
                )

    # Step 4: Create a RetrievalQA chain using the custom prompt.
    qa_chain = RetrievalQA.from_chain_type(
        llm=llm,
        chain_type="stuff",
        retriever=vectorstore.as_retriever(search_type = "mmr"),
        chain_type_kwargs={"prompt": custom_prompt}
    )

    # Run the QA chain using only the user's query.
    total_query = "Original query : " + user_query + "\nModified query : " + modified_query
    print(total_query)
    result = qa_chain.run(total_query)
    return {"result": result}


def Filter_bonds_agent(user_query):
  print("User Query : " , user_query)
  custom_prefix = """
  You are working with a CSV file loaded into a pandas dataframe called 'df' that has the following columns:
  'id',
  'created_at',
  'updated_at',
  'isin',
  'company_name',
  'issue_size',
  'allotment_date',
  'maturity_date',
  'face_value'
  recent_credit_rating,
  ownership	: Non PSU or PSU
  payment_frequency
  instrument_security :  Unsecured or secured
  tax	: YES or NO

  When you receive a query, first check if it explicitly mentions any of these column names.
  If a column name is mentioned, filter the dataframe using that column based on the input query,
  and then display only the first 5 rows of the filtered data.

  If none of the column names are mentioned, perform a general overview analysis of the CSV data.

  Always provide your chain-of-thought reasoning in the "Thought:" section.
  If no relevant data is found, respond with: "No relevant data found in this document."

  Begin!
  Question: {input}
  Thought: {agent_scratchpad}
  """


  # (Optional) Create a PromptTemplate instance if you wish to modify or inspect it.
  custom_prompt = PromptTemplate(
      template=custom_prefix,
      input_variables=["input", "agent_scratchpad"]
  )

  # Create the CSV agent with the custom prompt
  agent = create_csv_agent(
      llm=llm,
      path="data_dump/output_bonds2.csv",
      verbose=True,
      agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
      allow_dangerous_code=True,
      handle_parsing_errors=True,
      prefix=custom_prefix
  )

  st = agent.run(user_query)

  return st


def Bonds_Screener_Agent(user_query):
    global df_company_directoy
    global embeddings
    global llm
    # Step 1: Extract the ISIN from the user query.
    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the company name mentioned.
        Query: {query}
        Only output the company name as a string.
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_company = result.content.strip()

    # Filter the dataframe for the matching ISIN.
    df_isin = df_company_directoy[df_company_directoy["company_name"] == possible_company]
    df_isin.reset_index(drop=True, inplace=True)

    if df_isin.empty:
        return {"result": "No matching ISIN found."}


    # Step 3: Modify the query using the LLM to focus on the bond details.
    modification_prompt_template = PromptTemplate(
        template="""
    You are a financial analyst specializing in financial analysis of bond-issuing firms.

    TASK: Rewrite the query below without writing the company name.

    AVAILABLE DATA COLUMNS and their description
    company_name – Registered name of the company issuing the bond.
    all_isin_codes_of_bonds_issued_by_the_company – List of ISIN (International Securities Identification Numbers) associated with the company.
    id – Unique identifier for the record.
    created_at – Timestamp when the record was created.
    updated_at – Timestamp of the last update.
    company_industry – Industry classification of the company.
    description – Brief description of the company.
    key_metrics – Important financial and operational metrics.
    income_statement – Financial details from the company’s income statement.
    balance_sheet – Company’s financial position, including assets and liabilities.
    cashflow – Cash inflows and outflows over a period.
    lenders_profile – Information about lenders associated with the company.
    comparison – Comparative financial analysis with industry peers.
    borrowers_profile – Profile details of entities borrowing from the company.
    shareholding_profile – Ownership structure of the company.
    pros – Advantages or strengths of the company.
    cons – Challenges or weaknesses of the company.
    key_personnel – Details of important executives and decision-makers.
    news_and_events – Relevant news and events related to the company.

    Original query: {query}

    Your rewritten query should focus on what information the user needs and reference only one of the appropriate columns along with description from the list above.

    Modified query:
    """,
        input_variables=["query"]
    )

    modification_prompt = modification_prompt_template.format(query=user_query)
    modification_result = llm.invoke(modification_prompt)
    modified_query = modification_result.content.strip()

    # Build the document from the filtered bond details.
    doc_content = "\n".join([f"{col}: {df_isin.at[0, col]}" for col in df_isin.columns])
    document = Document(page_content=doc_content)
    documents = [document]

    # Step 2: Split the text into smaller chunks for better retrieval.
    text_splitter = CharacterTextSplitter(separator="\n", chunk_size=500, chunk_overlap=50)
    docs = text_splitter.split_documents(documents)

    vectorstore = FAISS.from_documents(docs, embeddings)

    # Step 3: Create a custom prompt that focuses on bond details.
    # Step 3: Create a custom prompt that focuses on bond details.
    custom_prompt = PromptTemplate(
        input_variables=["context", "question"],
        template="""You are a knowledgeable financial analyst specialized in bond details.
        Utilize the provided bond details to answer the following question. Output the answer nicely
        If the details are insufficient to answer the question, please indicate that explicitly.
        concentrate more on the "Original query" than the "Modified query"
        Bond Details:
        {context}

        Question:
        {question}

        Answer:"""
                )

    # Step 4: Create a RetrievalQA chain using the custom prompt.
    qa_chain = RetrievalQA.from_chain_type(
        llm=llm,
        chain_type="stuff",
        retriever=vectorstore.as_retriever(),
        chain_type_kwargs={"prompt": custom_prompt}
    )

    # Run the QA chain using only the user's query.
    total_query = "Original query : " + user_query + "\nModified query : " + modified_query
    result = qa_chain.run(total_query)
    return {"result": result}


def Bond_Calculator_Agent(user_query):
    global df_cash_flows
    global llm
    global df_filtering
    # Step 1: Extract the ISIN from the user query.
    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the ISIN mentioned.
        Query: {query}
        Only output the ISIN as a string.
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_ISIN = result.content.strip()

    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the units (the number) mentioned and no other charectors.
        Query: {query}
        Only output the units as a string .
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_units = result.content.strip()

    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the date mentioned.
        Query: {query}
        Only output the date as a string.
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_settlement_date = result.content.strip()

    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the ytm mentioned.
        Query: {query}
        Only output the ytm as a string with just a number.
        if it is not present output 'xc'
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_ytm = result.content.strip()

    extraction_prompt_template = PromptTemplate(
        template="""
        Given the following query, extract only the price mentioned.
        Query: {query}
        Only output the price as a string with just a number.
        if it is not present output 'xc'
        """,
        input_variables=["query"]
    )
    extraction_prompt = extraction_prompt_template.format(query=user_query)
    result = llm.invoke(extraction_prompt)
    possible_price = result.content.strip()

    face_value_per_unit = df_filtering[df_filtering["isin"] == possible_ISIN]["face_value"].values[0]
    Coupon = df_filtering[df_filtering["isin"] == possible_ISIN]["coupon_rate"].values[0]

    isin = possible_ISIN
    settlement_date = possible_settlement_date
    units = possible_units
    ytm = possible_ytm
    price = possible_price


    if (ytm == "xc" and price == "xc") or (ytm != "xc" and price != "xc"):
      raise ValueError("Please provide exactly one of ytm or price: one must be given, not both.")

    if(price == "xc"):
      ytm = float(ytm)
    if(ytm == "xc"):
      price = float(price)

    # Convert settlement_date to datetime
    settlement_date_dt = pd.to_datetime(settlement_date)

    # --- Select required columns and filter by ISIN ---
    # Assumes df is a global DataFrame containing cash flow data.
    cf_df = df_cash_flows[df_cash_flows["isin"] == isin][["cash_flow_date", "cash_flow_amount", "record_date",
                                      "principal_amount", "interest_amount"]].copy()
    cf_df["cash_flow_date"] = pd.to_datetime(cf_df["cash_flow_date"])
    cf_df["index"] = cf_df.index

    # --- Filter for cash flows after the settlement date ---
    cf_df2 = cf_df[cf_df["cash_flow_date"] > settlement_date_dt].copy()
    cf_df2.reset_index(inplace=True)
    if not cf_df2.empty:
        if cf_df2.loc[0, "index"] == 0:
            cf_df3 = cf_df[cf_df["index"] >= cf_df2.loc[0, "index"]].copy()
        else:
            cf_df3 = cf_df[cf_df["index"] >= cf_df2.loc[0, "index"] - 1].copy()
    else:
        # If no cash flows occur after settlement, use the entire filtered DataFrame.
        cf_df3 = cf_df.copy()
    cf_df = cf_df3

    # Multiply cash flow amount by units
    units = float(units)
    cf_df["cash_flow_amount"] = cf_df["cash_flow_amount"] * units

    # Create new row with the settlement date and zeros for other columns
    new_row = {
        "cash_flow_date": settlement_date_dt,
        "cash_flow_amount": 0,
        "record_date": settlement_date_dt,  # assuming record_date equals settlement_date
        "principal_amount": 0,
        "interest_amount": 0,
        "index": -1  # dummy index value
    }
    # Insert the new row at index 1
    cf_df = pd.concat([cf_df.iloc[:1], pd.DataFrame([new_row]), cf_df.iloc[1:]], ignore_index=True)

    # Define the xnpv function (similar to Excel's XNPV)
    def xnpv(rate, values, dates):
        if rate <= -1.0:
            return float('inf')

        d0 = dates[0]
        return sum(vi / (1.0 + rate) ** ((di - d0).days / 365.0) for vi, di in zip(values, dates))

    trade_FV = face_value_per_unit * units

    # Create a new DataFrame copy for NPV/yield calculations.
    # Drop the row corresponding to the original first row.
    cf_df_new = cf_df.copy().drop(index=0).reset_index(drop=True)
    cf_df_new["cash_flow_date"] = pd.to_datetime(cf_df_new["cash_flow_date"])

    # Two different branches based on the provided input.
    if ytm != "xc":
        # --- When yield is provided, calculate the bond price and consideration metrics ---
        values = cf_df_new["cash_flow_amount"].tolist()
        dates = cf_df_new["cash_flow_date"].tolist()
        npv_val = round(xnpv(ytm, values, dates), 2)

        # Calculate accrued interest based on the first cash flow date in the filtered DataFrame
        accrued_interest = round(trade_FV * (settlement_date_dt - cf_df["cash_flow_date"].iloc[0]).days / 365 * Coupon, 2)
        clean_price = round((npv_val - accrued_interest) * 100 / trade_FV, 4)
        dirty_price = round(npv_val * 100 / trade_FV, 4)
        consideration = round(((clean_price * trade_FV) / 100) + accrued_interest, 2)
        stamp_duty = round(consideration * 0.000001, 0)
        total_consideration = stamp_duty + consideration

        return {
            "npv": npv_val,
            "accrued_interest": accrued_interest,
            "clean_price": clean_price,
            "dirty_price": dirty_price,
            "consideration": consideration,
            "stamp_duty": stamp_duty,
            "total_consideration": total_consideration
        }
    else:
        # --- When price is provided, calculate yield ---
        # Copy the cash flow DataFrame and set the first cash flow to -price.
        inv_df = cf_df_new.copy()
        inv_df.loc[0, "cash_flow_amount"] = -price

        values = inv_df["cash_flow_amount"].tolist()
        dates = inv_df["cash_flow_date"].tolist()
        yield_percent = xirr(dates, values) * 100
        yield_percent = round(yield_percent, 4)
        return {"yield_percent": yield_percent}


def Cash_flow_agent(user_query):
  custom_prefix = """
  You are working with a CSV file loaded into a pandas dataframe called 'df' that has the following columns:
  The columns in order are:

  - isin
  - cash_flow_date
  - cash_flow_amount
  - record_date
  - principal_amount
  - interest_amount
  - tds_amount
  - remaining_principal
  - state
  - created_at
  - updated_at

  When you receive a query, first check if it explicitly mentions any of these column names.
  If a column name is mentioned, filter the dataframe using that column based on the input query,
  and then display all the rows of the fetched data

  if asked about the cashflow information of particular isin give only the filtered data with only cash_flow_date , principal_amount and interest_amount columns

  If none of the column names are mentioned, perform a general overview analysis of the CSV data.

  Always provide your chain-of-thought reasoning in the "Thought:" section.
  If no relevant data is found, respond with: "No relevant data found in this document."

  Begin!
  Question: {input}
  Thought: {agent_scratchpad}
  """


  # (Optional) Create a PromptTemplate instance if you wish to modify or inspect it.
  custom_prompt = PromptTemplate(
      template=custom_prefix,
      input_variables=["input", "agent_scratchpad"]
  )

  # Create the CSV agent with the custom prompt
  agent = create_csv_agent(
      llm=llm,
      path="data_dump/cashflows_202503011113.csv",
      verbose=True,
      agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
      allow_dangerous_code=True,
      handle_parsing_errors=True,
      prefix=custom_prefix
  )

  st = agent.run(user_query)

  return st


def Bond_Finder_Agent(user_query):
  custom_prefix = """
  You are working with a CSV file loaded into a pandas dataframe called 'df' that has the following columns:
  The columns in order are:

  Issuer Name
  Rating
  Yield
  Range
  Available At
  ISIN
  Yield
  Maturity Date
  Provider

  When you receive a query, first check if it explicitly mentions any of these column names.
  If a column name is mentioned, filter the dataframe using that column based on the input query
  Max give not more than 20 rows in the dataframe.

  If none of the column names are mentioned, perform a general overview analysis of the CSV data.

  Always provide your chain-of-thought reasoning in the "Thought:" section.
  If no relevant data is found, respond with: "No relevant data found in this document."

  Begin!
  Question: {input}
  Thought: {agent_scratchpad}
  """


  # (Optional) Create a PromptTemplate instance if you wish to modify or inspect it.
  custom_prompt = PromptTemplate(
      template=custom_prefix,
      input_variables=["input", "agent_scratchpad"]
  )

  # Create the CSV agent with the custom prompt
  agent = create_csv_agent(
      llm=llm,
      path="data_dump/bond_data.csv",
      verbose=True,
      agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
      allow_dangerous_code=True,
      handle_parsing_errors=True,
      prefix=custom_prefix
  )

  st = agent.run(user_query)

  return st


tools = [
    Tool(
        name="Bonds_Directory_Agent",
        func=Bonds_Directory_Agent,
        description="""Use this tool when you need to look up details about a specific bond using its ISIN code... IMPORTANT: You must pass the ENTIRE original user query, for example:
  If user asks "What is the coupon rate for bond INE123456789?",
  pass the entire query "What is the coupon rate for bond INE123456789?" - NOT just "INE123456789"."""
    ),
    Tool(
        name="Bond_Screener_Agent",
        func=Bonds_Screener_Agent,  # FIXED: Now using correct function
        description="Use this tool to perform company-level financial analysis..."
    ),
    Tool(
        name="Bond_Calculator_Agent",
        func=Bond_Calculator_Agent,
        description="to calculate the bond price or yield..."
    ),
    Tool(
        name="Filter_bonds_agent",
        func=Filter_bonds_agent,
        description="Use this tool when you need to analyze, filter, or compare multiple bonds..."
    ),
    Tool(
        name="Cash_flow_agent",
        func=Cash_flow_agent,
        description="Use this tool to retrieve the cash flow statements for a specific bond..."
    ),
    Tool(
        name="Bond_Finder_Agent",
        func=Bond_Finder_Agent,  # FIXED: Now using correct function
        description="Use this tool to find where the bonds are available..."
    ),
]

system_message = SystemMessage(
    content="""You are a financial bond information assistant that coordinates specialized agents.
Your job is to understand the user's query and route it to the most appropriate specialized agent:
***Compulsarily pass the entire query to the agent without fail***

1. Bonds_Directory_Agent: Use this ONLY when queries involve specific ISIN codes or detailed information about a specific bond. This definetly has information for ISIN in the user prompt
   Example queries: "What is the rating of bond with ISIN INE123456789?", "Show me details for ISIN INE123456789" , Where is ISIN INE06E507165 listed, and is it actively traded?

2. Bond_Screener_Agent: Use this when queries involve company-level financial analysis, company metrics, industry comparisons, company summaries, or listing all bonds issued by a specific company. This definetly has information for company in the user prompt
   Example queries: "What is the EPS of ABC company?", "Compare debt ratio of ABC and XYZ companies", "What is the rating of ABC company?", "Give me a summary about ABC company", "Show me all issuances done by XYZ LIMITED"

3. Bond_Calculator_Agent: Use this for bond price calculations, yield computations, and consideration calculations. This has something to calculate in the prompt
   Example queries: "How can I calculate clean price of a bond?", "What will be the consideration for ISIN INE456789012 for 100 units at 15-Mar-2025?", "Calculate price to yield for this bond"

4. Filter_bonds_agent: Use this when queries involve filtering, comparing, or analyzing multiple bonds based on various criteria. This has no information of ISIN or company name in the user prompt
   Example queries: "Find me secured debentures with coupon rate above 10% maturing after 2026", "Show all bonds rated AA+ or higher issued by financial institutions", "Which bonds are maturing in 2025?"

5. Cash_flow_agent: Use this when queries specifically request cash flow schedules or payment details for bonds.
   Example queries: "Show me the cash flow schedule for ISIN INE567890123", "When are the interest payment dates for bond INE123456789?"

6. Bond_Finder_Agent: Use this when users want to locate where bonds are available and compare yields across platforms.
   Example queries: "Where can I buy bonds from XYZ issuer?", "Which platform has the best yield for 5-year bonds?", "List all bonds available with a yield of more than 9%"

IMPORTANT:
- For queries about bond issuances by a company, use the Bond_Screener_Agent
- For filtering multiple bonds, use Filter_bonds_agent
- ONLY use Bonds_Directory_Agent when a specific ISIN is mentioned

Always choose the most appropriate agent based on the nature of the query.

When responding:
1. First determine which agent is most appropriate
2. Route the entire query what the user has prompted to that agent when calling the agent
3. Provide a complete, accurate response based on the information available
4. Dont ask for additional information but give the direct answer based on the query
5. Do not produce any any agent or column information in the output
"""
)


# Create a proper prompt template using your system message
prompt = ChatPromptTemplate.from_messages([
    ("system", system_message.content),  # Use the content from your SystemMessage
    ("human", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad")  # Required for agent's intermediate steps
])


# Create the agent from the tools and the LLM
agent = create_openai_tools_agent(llm, tools, prompt)

# Create an agent executor
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,
    handle_parsing_errors=True,
)

def process_user_query(query):
    """
    Process a user query through the orchestration system.

    Args:
        query (str): The user's query about bonds

    Returns:
        str: The response from the appropriate specialized agent
    """
    # Invoke the agent executor with the query
    response = agent_executor.invoke({"input": query, "max_tokens": 2000})
    
    # Return the agent's response
    return response.get("output")

# process_user_query("What is the face value of ISIN INE003L07077 listed")

"""### Rough"""



#INE06E507165

